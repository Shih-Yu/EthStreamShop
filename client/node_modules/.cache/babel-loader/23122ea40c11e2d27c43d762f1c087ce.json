{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcEngine = void 0;\n\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\n\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\n\n\nclass JsonRpcEngine extends safe_event_emitter_1.default {\n  constructor() {\n    super();\n    this._middleware = [];\n  }\n  /**\n   * Add a middleware function to the engine's middleware stack.\n   *\n   * @param middleware - The middleware function to add.\n   */\n\n\n  push(middleware) {\n    this._middleware.push(middleware);\n  }\n\n  handle(req, cb) {\n    if (cb && typeof cb !== 'function') {\n      throw new Error('\"callback\" must be a function if provided.');\n    }\n\n    if (Array.isArray(req)) {\n      if (cb) {\n        return this._handleBatch(req, cb);\n      }\n\n      return this._handleBatch(req);\n    }\n\n    if (cb) {\n      return this._handle(req, cb);\n    }\n\n    return this._promiseHandle(req);\n  }\n  /**\n   * Returns this engine as a middleware function that can be pushed to other\n   * engines.\n   *\n   * @returns This engine as a middleware function.\n   */\n\n\n  asMiddleware() {\n    return async (req, res, next, end) => {\n      try {\n        const [middlewareError, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);\n\n        if (isComplete) {\n          await JsonRpcEngine._runReturnHandlers(returnHandlers);\n          return end(middlewareError);\n        }\n\n        return next(async handlerCallback => {\n          try {\n            await JsonRpcEngine._runReturnHandlers(returnHandlers);\n          } catch (error) {\n            return handlerCallback(error);\n          }\n\n          return handlerCallback();\n        });\n      } catch (error) {\n        return end(error);\n      }\n    };\n  }\n\n  async _handleBatch(reqs, cb) {\n    // The order here is important\n    try {\n      // 2. Wait for all requests to finish, or throw on some kind of fatal\n      // error\n      const responses = await Promise.all( // 1. Begin executing each request in the order received\n      reqs.map(this._promiseHandle.bind(this))); // 3. Return batch response\n\n      if (cb) {\n        return cb(null, responses);\n      }\n\n      return responses;\n    } catch (error) {\n      if (cb) {\n        return cb(error);\n      }\n\n      throw error;\n    }\n  }\n  /**\n   * A promise-wrapped _handle.\n   */\n\n\n  _promiseHandle(req) {\n    return new Promise(resolve => {\n      this._handle(req, (_err, res) => {\n        // There will always be a response, and it will always have any error\n        // that is caught and propagated.\n        resolve(res);\n      });\n    });\n  }\n  /**\n   * Ensures that the request object is valid, processes it, and passes any\n   * error and the response object to the given callback.\n   *\n   * Does not reject.\n   */\n\n\n  async _handle(callerReq, cb) {\n    if (!callerReq || Array.isArray(callerReq) || typeof callerReq !== 'object') {\n      const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, {\n        request: callerReq\n      });\n      return cb(error, {\n        id: undefined,\n        jsonrpc: '2.0',\n        error\n      });\n    }\n\n    if (typeof callerReq.method !== 'string') {\n      const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, {\n        request: callerReq\n      });\n      return cb(error, {\n        id: callerReq.id,\n        jsonrpc: '2.0',\n        error\n      });\n    }\n\n    const req = Object.assign({}, callerReq);\n    const res = {\n      id: req.id,\n      jsonrpc: req.jsonrpc\n    };\n    let error = null;\n\n    try {\n      await this._processRequest(req, res);\n    } catch (_error) {\n      // A request handler error, a re-thrown middleware error, or something\n      // unexpected.\n      error = _error;\n    }\n\n    if (error) {\n      // Ensure no result is present on an errored response\n      delete res.result;\n\n      if (!res.error) {\n        res.error = eth_rpc_errors_1.serializeError(error);\n      }\n    }\n\n    return cb(error, res);\n  }\n  /**\n   * For the given request and response, runs all middleware and their return\n   * handlers, if any, and ensures that internal request processing semantics\n   * are satisfied.\n   */\n\n\n  async _processRequest(req, res) {\n    const [error, isComplete, returnHandlers] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware); // Throw if \"end\" was not called, or if the response has neither a result\n    // nor an error.\n\n    JsonRpcEngine._checkForCompletion(req, res, isComplete); // The return handlers should run even if an error was encountered during\n    // middleware processing.\n\n\n    await JsonRpcEngine._runReturnHandlers(returnHandlers); // Now we re-throw the middleware processing error, if any, to catch it\n    // further up the call chain.\n\n    if (error) {\n      throw error;\n    }\n  }\n  /**\n   * Serially executes the given stack of middleware.\n   *\n   * @returns An array of any error encountered during middleware execution,\n   * a boolean indicating whether the request was completed, and an array of\n   * middleware-defined return handlers.\n   */\n\n\n  static async _runAllMiddleware(req, res, middlewareStack) {\n    const returnHandlers = [];\n    let error = null;\n    let isComplete = false; // Go down stack of middleware, call and collect optional returnHandlers\n\n    for (const middleware of middlewareStack) {\n      [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);\n\n      if (isComplete) {\n        break;\n      }\n    }\n\n    return [error, isComplete, returnHandlers.reverse()];\n  }\n  /**\n   * Runs an individual middleware.\n   *\n   * @returns An array of any error encountered during middleware exection,\n   * and a boolean indicating whether the request should end.\n   */\n\n\n  static _runMiddleware(req, res, middleware, returnHandlers) {\n    return new Promise(resolve => {\n      const end = err => {\n        const error = err || res.error;\n\n        if (error) {\n          res.error = eth_rpc_errors_1.serializeError(error);\n        } // True indicates that the request should end\n\n\n        resolve([error, true]);\n      };\n\n      const next = returnHandler => {\n        if (res.error) {\n          end(res.error);\n        } else {\n          if (returnHandler) {\n            if (typeof returnHandler !== 'function') {\n              end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: \"next\" return handlers must be functions. ` + `Received \"${typeof returnHandler}\" for request:\\n${jsonify(req)}`, {\n                request: req\n              }));\n            }\n\n            returnHandlers.push(returnHandler);\n          } // False indicates that the request should not end\n\n\n          resolve([null, false]);\n        }\n      };\n\n      try {\n        middleware(req, res, next, end);\n      } catch (error) {\n        end(error);\n      }\n    });\n  }\n  /**\n   * Serially executes array of return handlers. The request and response are\n   * assumed to be in their scope.\n   */\n\n\n  static async _runReturnHandlers(handlers) {\n    for (const handler of handlers) {\n      await new Promise((resolve, reject) => {\n        handler(err => err ? reject(err) : resolve());\n      });\n    }\n  }\n  /**\n   * Throws an error if the response has neither a result nor an error, or if\n   * the \"isComplete\" flag is falsy.\n   */\n\n\n  static _checkForCompletion(req, res, isComplete) {\n    if (!('result' in res) && !('error' in res)) {\n      throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:\\n${jsonify(req)}`, {\n        request: req\n      });\n    }\n\n    if (!isComplete) {\n      throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:\\n${jsonify(req)}`, {\n        request: req\n      });\n    }\n  }\n\n}\n\nexports.JsonRpcEngine = JsonRpcEngine;\n\nfunction jsonify(request) {\n  return JSON.stringify(request, null, 2);\n}","map":{"version":3,"sources":["../src/JsonRpcEngine.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.JsonRpcEngine = void 0;\nconst safe_event_emitter_1 = __importDefault(require(\"@metamask/safe-event-emitter\"));\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\n/**\n * A JSON-RPC request and response processor.\n * Give it a stack of middleware, pass it requests, and get back responses.\n */\nclass JsonRpcEngine extends safe_event_emitter_1.default {\n    constructor() {\n        super();\n        this._middleware = [];\n    }\n    /**\n     * Add a middleware function to the engine's middleware stack.\n     *\n     * @param middleware - The middleware function to add.\n     */\n    push(middleware) {\n        this._middleware.push(middleware);\n    }\n    handle(req, cb) {\n        if (cb && typeof cb !== 'function') {\n            throw new Error('\"callback\" must be a function if provided.');\n        }\n        if (Array.isArray(req)) {\n            if (cb) {\n                return this._handleBatch(req, cb);\n            }\n            return this._handleBatch(req);\n        }\n        if (cb) {\n            return this._handle(req, cb);\n        }\n        return this._promiseHandle(req);\n    }\n    /**\n     * Returns this engine as a middleware function that can be pushed to other\n     * engines.\n     *\n     * @returns This engine as a middleware function.\n     */\n    asMiddleware() {\n        return async (req, res, next, end) => {\n            try {\n                const [middlewareError, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);\n                if (isComplete) {\n                    await JsonRpcEngine._runReturnHandlers(returnHandlers);\n                    return end(middlewareError);\n                }\n                return next(async (handlerCallback) => {\n                    try {\n                        await JsonRpcEngine._runReturnHandlers(returnHandlers);\n                    }\n                    catch (error) {\n                        return handlerCallback(error);\n                    }\n                    return handlerCallback();\n                });\n            }\n            catch (error) {\n                return end(error);\n            }\n        };\n    }\n    async _handleBatch(reqs, cb) {\n        // The order here is important\n        try {\n            // 2. Wait for all requests to finish, or throw on some kind of fatal\n            // error\n            const responses = await Promise.all(\n            // 1. Begin executing each request in the order received\n            reqs.map(this._promiseHandle.bind(this)));\n            // 3. Return batch response\n            if (cb) {\n                return cb(null, responses);\n            }\n            return responses;\n        }\n        catch (error) {\n            if (cb) {\n                return cb(error);\n            }\n            throw error;\n        }\n    }\n    /**\n     * A promise-wrapped _handle.\n     */\n    _promiseHandle(req) {\n        return new Promise((resolve) => {\n            this._handle(req, (_err, res) => {\n                // There will always be a response, and it will always have any error\n                // that is caught and propagated.\n                resolve(res);\n            });\n        });\n    }\n    /**\n     * Ensures that the request object is valid, processes it, and passes any\n     * error and the response object to the given callback.\n     *\n     * Does not reject.\n     */\n    async _handle(callerReq, cb) {\n        if (!callerReq ||\n            Array.isArray(callerReq) ||\n            typeof callerReq !== 'object') {\n            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof callerReq}`, { request: callerReq });\n            return cb(error, { id: undefined, jsonrpc: '2.0', error });\n        }\n        if (typeof callerReq.method !== 'string') {\n            const error = new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof callerReq.method}`, { request: callerReq });\n            return cb(error, { id: callerReq.id, jsonrpc: '2.0', error });\n        }\n        const req = Object.assign({}, callerReq);\n        const res = {\n            id: req.id,\n            jsonrpc: req.jsonrpc,\n        };\n        let error = null;\n        try {\n            await this._processRequest(req, res);\n        }\n        catch (_error) {\n            // A request handler error, a re-thrown middleware error, or something\n            // unexpected.\n            error = _error;\n        }\n        if (error) {\n            // Ensure no result is present on an errored response\n            delete res.result;\n            if (!res.error) {\n                res.error = eth_rpc_errors_1.serializeError(error);\n            }\n        }\n        return cb(error, res);\n    }\n    /**\n     * For the given request and response, runs all middleware and their return\n     * handlers, if any, and ensures that internal request processing semantics\n     * are satisfied.\n     */\n    async _processRequest(req, res) {\n        const [error, isComplete, returnHandlers,] = await JsonRpcEngine._runAllMiddleware(req, res, this._middleware);\n        // Throw if \"end\" was not called, or if the response has neither a result\n        // nor an error.\n        JsonRpcEngine._checkForCompletion(req, res, isComplete);\n        // The return handlers should run even if an error was encountered during\n        // middleware processing.\n        await JsonRpcEngine._runReturnHandlers(returnHandlers);\n        // Now we re-throw the middleware processing error, if any, to catch it\n        // further up the call chain.\n        if (error) {\n            throw error;\n        }\n    }\n    /**\n     * Serially executes the given stack of middleware.\n     *\n     * @returns An array of any error encountered during middleware execution,\n     * a boolean indicating whether the request was completed, and an array of\n     * middleware-defined return handlers.\n     */\n    static async _runAllMiddleware(req, res, middlewareStack) {\n        const returnHandlers = [];\n        let error = null;\n        let isComplete = false;\n        // Go down stack of middleware, call and collect optional returnHandlers\n        for (const middleware of middlewareStack) {\n            [error, isComplete] = await JsonRpcEngine._runMiddleware(req, res, middleware, returnHandlers);\n            if (isComplete) {\n                break;\n            }\n        }\n        return [error, isComplete, returnHandlers.reverse()];\n    }\n    /**\n     * Runs an individual middleware.\n     *\n     * @returns An array of any error encountered during middleware exection,\n     * and a boolean indicating whether the request should end.\n     */\n    static _runMiddleware(req, res, middleware, returnHandlers) {\n        return new Promise((resolve) => {\n            const end = (err) => {\n                const error = err || res.error;\n                if (error) {\n                    res.error = eth_rpc_errors_1.serializeError(error);\n                }\n                // True indicates that the request should end\n                resolve([error, true]);\n            };\n            const next = (returnHandler) => {\n                if (res.error) {\n                    end(res.error);\n                }\n                else {\n                    if (returnHandler) {\n                        if (typeof returnHandler !== 'function') {\n                            end(new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: \"next\" return handlers must be functions. ` +\n                                `Received \"${typeof returnHandler}\" for request:\\n${jsonify(req)}`, { request: req }));\n                        }\n                        returnHandlers.push(returnHandler);\n                    }\n                    // False indicates that the request should not end\n                    resolve([null, false]);\n                }\n            };\n            try {\n                middleware(req, res, next, end);\n            }\n            catch (error) {\n                end(error);\n            }\n        });\n    }\n    /**\n     * Serially executes array of return handlers. The request and response are\n     * assumed to be in their scope.\n     */\n    static async _runReturnHandlers(handlers) {\n        for (const handler of handlers) {\n            await new Promise((resolve, reject) => {\n                handler((err) => (err ? reject(err) : resolve()));\n            });\n        }\n    }\n    /**\n     * Throws an error if the response has neither a result nor an error, or if\n     * the \"isComplete\" flag is falsy.\n     */\n    static _checkForCompletion(req, res, isComplete) {\n        if (!('result' in res) && !('error' in res)) {\n            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:\\n${jsonify(req)}`, { request: req });\n        }\n        if (!isComplete) {\n            throw new eth_rpc_errors_1.EthereumRpcError(eth_rpc_errors_1.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:\\n${jsonify(req)}`, { request: req });\n        }\n    }\n}\nexports.JsonRpcEngine = JsonRpcEngine;\nfunction jsonify(request) {\n    return JSON.stringify(request, null, 2);\n}\n"]},"metadata":{},"sourceType":"script"}